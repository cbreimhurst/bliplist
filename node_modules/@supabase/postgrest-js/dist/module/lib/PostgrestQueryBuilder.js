import { PostgrestBuilder } from './types';
import PostgrestFilterBuilder from './PostgrestFilterBuilder';
/**
 * CRUD
 */
export default class PostgrestQueryBuilder extends PostgrestBuilder {
    constructor(url, { headers = {}, schema } = {}) {
        super({});
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
    }
    /**
     * Performs horizontal filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     */
    select(columns = '*') {
        this.method = 'GET';
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = columns
            .split('')
            .map((c) => {
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        })
            .join('');
        this.url.searchParams.set('select', cleanedColumns);
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs an INSERT into the table.
     *
     * @param values  The values to insert.
     * @param upsert  If `true`, performs an UPSERT.
     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.
     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.
     */
    insert(values, { upsert = false, onConflict, returning = 'representation', } = {}) {
        this.method = 'POST';
        let prefersHeaders = [];
        prefersHeaders.push(`return=${returning}`);
        if (upsert)
            prefersHeaders.push('resolution=merge-duplicates');
        this.headers['Prefer'] = prefersHeaders.join(',');
        if (upsert && onConflict !== undefined)
            this.url.searchParams.set('on_conflict', onConflict);
        this.body = values;
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs an UPDATE on the table.
     *
     * @param values  The values to update.
     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.
     */
    update(values, { returning = 'representation' } = {}) {
        this.method = 'PATCH';
        this.headers['Prefer'] = `return=${returning}`;
        this.body = values;
        return new PostgrestFilterBuilder(this);
    }
    /**
     * Performs a DELETE on the table.
     *
     * @param returning  If `true`, return the deleted row(s) in the response.
     */
    delete({ returning = 'representation', } = {}) {
        this.method = 'DELETE';
        this.headers['Prefer'] = `return=${returning}`;
        return new PostgrestFilterBuilder(this);
    }
    /** @internal */
    rpc(params) {
        this.method = 'POST';
        this.body = params;
        return this;
    }
}
//# sourceMappingURL=PostgrestQueryBuilder.js.map