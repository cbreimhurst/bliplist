"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GoTrueApi_1 = __importDefault(require("./GoTrueApi"));
const helpers_1 = require("./lib/helpers");
const constants_1 = require("./lib/constants");
const DEFAULT_OPTIONS = {
    url: constants_1.GOTRUE_URL,
    autoRefreshToken: true,
    persistSession: true,
    localStorage: globalThis.localStorage,
    detectSessionInUrl: true,
    headers: constants_1.DEFAULT_HEADERS,
};
class GoTrueClient {
    /**
     * Create a new client for use in the browser.
     * @param options.url The URL of the GoTrue server.
     * @param options.headers Any additional headers to send to the GoTrue server.
     * @param options.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.localStorage
     */
    constructor(options) {
        this.stateChangeEmmitters = new Map();
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.currentUser = null;
        this.currentSession = null;
        this.autoRefreshToken = settings.autoRefreshToken;
        this.persistSession = settings.persistSession;
        this.localStorage = new helpers_1.LocalStorage(settings.localStorage);
        this.api = new GoTrueApi_1.default({ url: settings.url, headers: settings.headers });
        this._recoverSession();
        // Handle the OAuth redirect
        try {
            if (settings.detectSessionInUrl && helpers_1.isBrowser() && !!helpers_1.getParameterByName('access_token')) {
                this.getSessionFromUrl({ storeSession: true });
            }
        }
        catch (error) {
            console.log('Error getting session from URL.');
        }
    }
    /**
     * Creates a new user.
     * @param credentials The user login details.
     * @param credentials.email The user's email address.
     * @param credentials.password The user's password.
     */
    signUp(credentials) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._removeSession();
                let { data, error } = yield this.api.signUpWithEmail(credentials.email, credentials.password);
                if (error)
                    throw error;
                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) {
                    this._saveSession(data);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
                return { data, user: (_b = data === null || data === void 0 ? void 0 : data.user) !== null && _b !== void 0 ? _b : null, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Log in an existing user, or login via a third-party provider.
     * @param credentials The user login details.
     * @param credentials.email The user's email address.
     * @param credentials.password The user's password.
     * @param credentials.provider One of the providers supported by GoTrue.
     */
    signIn(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._removeSession();
                const { email, password, provider } = credentials;
                if (email && !password) {
                    const { error } = yield this.api.sendMagicLinkEmail(email);
                    return { data: null, user: null, error };
                }
                if (email && password)
                    return this._handeEmailSignIn(email, password);
                if (provider)
                    return this._handeProviderSignIn(provider);
                else
                    throw new Error(`You must provide either an email or a third-party provider.`);
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Returns the user data, if there is a logged in user.
     */
    user() {
        return this.currentUser;
    }
    /**
     * Returns the session data, if there is an active session.
     */
    session() {
        return this.currentSession;
    }
    /**
     * Force refreshes the session including the user data in case it was updated in a different session.
     */
    refreshSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))
                    throw new Error('Not logged in.');
                yield this._callRefreshToken();
                let { data, error } = yield this.api.getUser(this.currentSession.access_token);
                if (error)
                    throw error;
                this.currentUser = data;
                return { data: this.currentSession, user: this.currentUser, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Updates user data, if there is a logged in user.
     */
    update(attributes) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))
                    throw new Error('Not logged in.');
                let { data, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);
                if (error)
                    throw error;
                this.currentUser = data;
                this._notifyAllSubscribers('USER_UPDATED');
                return { data, user: this.currentUser, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    /**
     * Gets the session data from a URL string
     * @param options.storeSession Optionally store the session in the browser
     */
    getSessionFromUrl(options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!helpers_1.isBrowser())
                    throw new Error('No browser detected.');
                const error_description = helpers_1.getParameterByName('error_description');
                if (error_description)
                    throw new Error(error_description);
                const access_token = helpers_1.getParameterByName('access_token');
                const expires_in = helpers_1.getParameterByName('expires_in');
                const refresh_token = helpers_1.getParameterByName('refresh_token');
                const token_type = helpers_1.getParameterByName('token_type');
                if (!access_token)
                    throw new Error('No access_token detected.');
                if (!expires_in)
                    throw new Error('No expires_in detected.');
                if (!refresh_token)
                    throw new Error('No refresh_token detected.');
                if (!token_type)
                    throw new Error('No token_type detected.');
                let { data: user, error } = yield this.api.getUser(access_token);
                if (error)
                    throw error;
                const session = {
                    access_token,
                    expires_in: parseInt(expires_in),
                    refresh_token,
                    token_type,
                    user,
                };
                if (options === null || options === void 0 ? void 0 : options.storeSession) {
                    this._saveSession(session);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
                // Remove tokens from URL
                window.location.hash = '';
                return { data: session, error: null };
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    /**
     * Signs out the current user, if there is a logged in user.
     */
    signOut() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentSession) {
                const { error } = yield this.api.signOut(this.currentSession.access_token);
                if (error)
                    return { error };
            }
            this._removeSession();
            this._notifyAllSubscribers('SIGNED_OUT');
            return { error: null };
        });
    }
    /**
     * Receive a notification every time an auth event happens.
     * @returns {Subscription} A subscription object which can be used to unsubcribe itself.
     */
    onAuthStateChange(callback) {
        try {
            const id = helpers_1.uuid();
            let self = this;
            const subscription = {
                id,
                callback,
                unsubscribe: () => {
                    self.stateChangeEmmitters.delete(id);
                },
            };
            this.stateChangeEmmitters.set(id, subscription);
            return { data: subscription, error: null };
        }
        catch (error) {
            return { data: null, error };
        }
    }
    _handeEmailSignIn(email, password) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let { data, error } = yield this.api.signInWithEmail(email, password);
                if (error || !data)
                    return { data: null, user: null, error };
                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) {
                    this._saveSession(data);
                    this._notifyAllSubscribers('SIGNED_IN');
                }
                return { data, user: data.user, error: null };
            }
            catch (error) {
                return { data: null, user: null, error };
            }
        });
    }
    _handeProviderSignIn(provider) {
        let url = this.api.getUrlForProvider(provider);
        try {
            // try to open on the browser
            if (helpers_1.isBrowser()) {
                window.location.href = url;
            }
            return { provider, url, data: null, user: null, error: null };
        }
        catch (error) {
            // fallback to returning the URL
            if (!!url)
                return { provider, url, data: null, user: null, error: null };
            else
                return { data: null, user: null, error };
        }
    }
    _saveSession(session) {
        this.currentSession = session;
        this.currentUser = session.user;
        let tokenExpirySeconds = session['expires_in'];
        if (this.autoRefreshToken && tokenExpirySeconds) {
            setTimeout(this._callRefreshToken, (tokenExpirySeconds - 60) * 1000);
        }
        if (this.persistSession) {
            this._persistSession(this.currentSession, tokenExpirySeconds);
        }
    }
    _persistSession(currentSession, secondsToExpiry) {
        const timeNow = Math.round(Date.now() / 1000);
        const expiresAt = timeNow + secondsToExpiry;
        const data = { currentSession, expiresAt };
        helpers_1.isBrowser() && this.localStorage.setItem(constants_1.STORAGE_KEY, JSON.stringify(data));
    }
    _removeSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.currentSession = null;
            this.currentUser = null;
            helpers_1.isBrowser() && (yield this.localStorage.removeItem(constants_1.STORAGE_KEY));
        });
    }
    _recoverSession() {
        return __awaiter(this, void 0, void 0, function* () {
            // Note: this method is async to accomodate for AsyncStorage e.g. in React native.
            const json = helpers_1.isBrowser() && (yield this.localStorage.getItem(constants_1.STORAGE_KEY));
            if (json) {
                try {
                    const data = JSON.parse(json);
                    const { currentSession, expiresAt } = data;
                    const timeNow = Math.round(Date.now() / 1000);
                    if (expiresAt < timeNow) {
                        if (this.autoRefreshToken && currentSession.refresh_token) {
                            const { error } = yield this._callRefreshToken(currentSession.refresh_token);
                            if (error) {
                                console.log(error.message);
                                yield this._removeSession();
                            }
                            else {
                                this._notifyAllSubscribers('SIGNED_IN');
                            }
                        }
                        else {
                            this._removeSession();
                        }
                    }
                    else if (!currentSession || !currentSession.user) {
                        console.log('Current session is missing data.');
                        this._removeSession();
                    }
                    else {
                        this.currentSession = currentSession;
                        this.currentUser = currentSession.user;
                        this._notifyAllSubscribers('SIGNED_IN');
                        // schedule a refresh 60 seconds before token due to expire
                        setTimeout(this._callRefreshToken, (expiresAt - timeNow - 60) * 1000);
                    }
                }
                catch (err) {
                    console.error(err);
                    return null;
                }
            }
            return null;
        });
    }
    _callRefreshToken(refresh_token) {
        var _a;
        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (refresh_token) {
                    const { data, error } = yield this.api.refreshAccessToken(refresh_token);
                    if (data === null || data === void 0 ? void 0 : data.access_token) {
                        this.currentSession = data;
                        this.currentUser = this.currentSession.user;
                        const tokenExpirySeconds = data.expires_in;
                        if (this.autoRefreshToken && tokenExpirySeconds) {
                            setTimeout(this._callRefreshToken, (tokenExpirySeconds - 60) * 1000);
                        }
                        if (this.persistSession && this.currentUser) {
                            this._persistSession(this.currentSession, tokenExpirySeconds);
                        }
                    }
                    else {
                        throw error;
                    }
                    return { data, error: null };
                }
                else {
                    throw new Error('No current session.');
                }
            }
            catch (error) {
                return { data: null, error };
            }
        });
    }
    _notifyAllSubscribers(event) {
        this.stateChangeEmmitters.forEach((x) => x.callback(event, this.currentSession));
    }
}
exports.default = GoTrueClient;
//# sourceMappingURL=GoTrueClient.js.map